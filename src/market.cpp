/**
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
=xxdb
-----END PGP PUBLIC KEY BLOCK-----
 */

#include <boost/lexical_cast.hpp>

#include <coinsy/ask.hpp>
#include <coinsy/balance_manager.hpp>
#include <coinsy/bid.hpp>
#include <coinsy/credentials_manager.hpp>
#include <coinsy/crypto.hpp>
#include <coinsy/logger.hpp>
#include <coinsy/market.hpp>
#include <coinsy/stack_impl.hpp>
#include <coinsy/uri.hpp>

using namespace coinsy;

market::market(
    boost::asio::io_service & ios, stack_impl & owner,
    const std::string & symbols
    )
    : m_lowest_ask(0.0f)
    , m_highest_bid(0.0f)
    , io_service_(ios)
    , strand_(ios)
    , stack_impl_(owner)
    , timer_ask_lookup_(ios)
    , timer_bid_lookup_(ios)
    , timer_public_asks_(ios)
    , timer_public_bids_(ios)
{
    auto i = symbols.find("/");
    
    m_left_symbol = symbols.substr(0, i);
    m_right_symbol = symbols.substr(i + 1, symbols.size() - 1);
}

void market::start()
{
    assert(interval_lookup > 2);
    
    /**
     * Check the balance for the left symbol.
     */
    auto left_balance = stack_impl_.balance_manager_->check(m_left_symbol);
    
    log_debug(
        "Market " << name() << " got balance " << left_balance <<
        " for " << m_left_symbol << "."
    );
    
    /**
     * Check the balance for the right symbol.
     */
    auto right_balance = stack_impl_.balance_manager_->check(m_right_symbol);
    
    log_debug(
        "Market " << name() << " got balance " << right_balance <<
        " for " << m_right_symbol << "."
    );
    
    auto self(shared_from_this());
    
    /**
     * Perform an initial (delayed) ask lookup.
     */
    timer_ask_lookup_.expires_from_now(
        std::chrono::seconds(interval_lookup / 2)
    );
    timer_ask_lookup_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    lookup_ask();
                }
            }
        )
    );
    
    /**
     * Perform an initial (delayed) bid lookup.
     */
    timer_bid_lookup_.expires_from_now(std::chrono::seconds(interval_lookup));
    timer_bid_lookup_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    lookup_bid();
                }
            }
        )
    );
    
    assert(interval_maintanance == 4);
    
    /**
     * Perform an initial (delayed) public asks maintenance operation.
     */
    timer_public_asks_.expires_from_now(
        std::chrono::seconds(interval_maintanance / 2)
    );
    timer_public_asks_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    maintain_public_asks();
                }
            }
        )
    );
    
    /**
     * Perform an initial (delayed) public bids maintenance operation.
     */
    timer_public_bids_.expires_from_now(
        std::chrono::seconds(interval_maintanance)
    );
    timer_public_bids_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    maintain_public_bids();
                }
            }
        )
    );
}

void market::stop()
{
    timer_ask_lookup_.cancel();
    timer_bid_lookup_.cancel();
    timer_public_asks_.cancel();
    timer_public_bids_.cancel();
}

std::uint32_t market::place_ask(const float & price, const float & quantity)
{
    /**
     * Allocate the ask.
     */
    auto a = std::make_shared<ask>(
        io_service_, stack_impl_, name(), price, quantity,
        stack_impl_.username()
    );

    std::lock_guard<std::mutex> l1(mutex_open_asks_);
    
    /**
     * Retain the ask.
     */
    m_open_asks.push_back(a);
    
    /**
     * Start the ask.
     */
    a->start();
    
    return a->id();
}

std::uint32_t market::place_bid(const float & price, const float & quantity)
{
    /**
     * Allocate the bid.
     */
    auto b = std::make_shared<bid>(
        io_service_, stack_impl_, name(), price, quantity,
        stack_impl_.username()
    );
    
    std::lock_guard<std::mutex> l1(mutex_open_bids_);
    
    /**
     * Retain the bid.
     */
    m_open_bids.push_back(b);

    /**
     * Start the bid.
     */
    b->start();
    
    return b->id();
}

bool market::cancel_order(const std::uint32_t & id)
{
    bool found = false;
    
    std::lock_guard<std::mutex> l1(mutex_open_asks_);
    
    auto it = m_open_asks.begin();
    
    for (; it != m_open_asks.end(); ++it)
    {
        if ((*it)->id() == id)
        {
            log_debug("Market is canceling ask " << id << ".");
            
            (*it)->stop();
            
            m_open_asks.erase(it);
            
            found = true;
            
            break;
        }
    }
    
    if (found == false)
    {
        std::lock_guard<std::mutex> l1(mutex_open_bids_);
        
        auto it = m_open_bids.begin();
        
        for (; it != m_open_bids.end(); ++it)
        {
            if ((*it)->id() == id)
            {
                log_debug("Market is canceling bid " << id << ".");
                
                (*it)->stop();
                
                m_open_bids.erase(it);
                
                found = true;
                
                break;
            }
        }
    }
    
    return found;
}

void market::on_find_ask(database::query & q)
{
    auto price = std::stof(q.pairs()["__p"]);
    auto quantity = std::stof(q.pairs()["__q"]);
    auto seller = q.pairs()["seller"];
    auto id = boost::lexical_cast<std::uint32_t>(q.pairs()["id"]);
    auto __t = boost::lexical_cast<std::time_t>(q.pairs()["__t"]);
    auto _e = boost::lexical_cast<std::time_t>(q.pairs()["_e"]);
    
    log_debug(
        "Market " << name() << " found ask, price = " << price <<
        ", quantity = "<< quantity << ", seller = " << seller <<
        ", _e = " << _e  << "."
    );
    
    std::lock_guard<std::mutex> l1(mutex_public_asks_);
    
    bool found = false;
    
    for (auto & i: m_public_asks)
    {
        if (i->id() == id)
        {
            found = true;
            
            i->set_expires(std::time(0) + (_e < 0 ? 0 : _e));
            
            break;
        }
    }
    
    if (found == false)
    {
        /**
         * Allocate the ask.
         */
        auto a = std::make_shared<ask>(
            io_service_, stack_impl_, name(), price, quantity, seller, id, __t,
            _e
        );

        /**
         * Retain the ask.
         */
        m_public_asks.push_back(a);
    }

    std::lock_guard<std::mutex> l2(mutex_open_bids_);
    
    /**
     * Look for the first matching bid.
     */
    for (auto & i : m_open_bids)
    {
        if (
            i->id_transaction() == 0 && i->price() == price &&
            i->quantity() == quantity
            )
        {
            /**
             * Inform the bid.
             */
            i->on_find_ask(q);
        }
    }
}

void market::on_find_bid(database::query & q)
{
    auto price = std::stof(q.pairs()["__p"]);
    auto quantity = std::stof(q.pairs()["__q"]);
    auto buyer = q.pairs()["buyer"];
    auto id = boost::lexical_cast<std::uint32_t>(q.pairs()["id"]);
    auto __t = boost::lexical_cast<std::time_t>(q.pairs()["__t"]);
    auto _e = boost::lexical_cast<std::time_t>(q.pairs()["_e"])
    
    log_none(
        "Market " << name() << " found bid, price = " << price <<
        ", quantity = "<< quantity << ", buyer = " << buyer <<
        ", _e = " << _e << "."
    );
    
    std::lock_guard<std::mutex> l1(mutex_public_bids_);
    
    bool found = false;
    
    for (auto & i: m_public_bids)
    {
        if (i->id() == id)
        {
            found = true;
            
            i->set_expires(std::time(0) + (_e < 0 ? 0 : _e));
            
            break;
        }
    }
    
    if (found == false)
    {
        /**
         * Allocate the bid.
         */
        auto b = std::make_shared<bid>(
            io_service_, stack_impl_, name(), price, quantity, buyer, id, __t,
            _e
        );

        /**
         * Retain the bid.
         */
        m_public_bids.push_back(b);
    }

    std::lock_guard<std::mutex> l2(mutex_open_asks_);
    
    for (auto & i : m_open_asks)
    {
        if (i->price() == price &&i->quantity() == quantity)
        {
            /**
             * We found a matching bid for one of our open asks, inform the ask.
             */
            i->on_find_bid(q);
        }
    }
}

void market::on_route_buy(database::query & q)
{
    std::lock_guard<std::mutex> l1(mutex_open_asks_);
    
    for (auto & i : m_open_asks)
    {
        float price = std::stof(q.pairs()["__p"]);
        float quantity = std::stof(q.pairs()["__q"]);
        auto tid = boost::lexical_cast<std::uint32_t>(
            q.pairs()["tid"]
        );
        
        if (
            (i->id_transaction() == 0 || i->id_transaction() == tid)
            && i->price() == price && i->quantity() == quantity
            )
        {
            /**
             * Inform the ask.
             */
            i->on_route_buy(q);
            
            break;
        }
    }
}

void market::on_route_sell(database::query & q)
{
    std::lock_guard<std::mutex> l1(mutex_open_bids_);
    
    for (auto & i : m_open_bids)
    {
        auto tid = boost::lexical_cast<std::uint32_t>(
            q.pairs()["tid"]
        );
        
        if (i->id_transaction() == tid)
        {
            /**
             * Inform the bid.
             */
            i->on_route_sell(q);
        }
    }
}

void market::on_find_trade(database::query & q)
{
    auto tid = boost::lexical_cast<std::uint32_t>(q.pairs()["tid"]);
    
    std::lock_guard<std::mutex> l1(mutex_open_asks_);
    
    for (auto & i : m_open_asks)
    {
        if (i->id_transaction() == tid)
        {
            i->on_find_trade(q);
            
            break;
        }
    }
    
    std::lock_guard<std::mutex> l2(mutex_open_bids_);
    
    for (auto & i : m_open_bids)
    {
        if (i->id_transaction() == tid)
        {
            i->on_find_trade(q);
            
            break;
        }
    }
}

const std::string market::name() const
{
    return m_left_symbol + "/" + m_right_symbol;
}

const std::string & market::left_symbol() const
{
    return m_left_symbol;
}

const std::string & market::right_symbol() const
{
    return m_right_symbol;
}

bool market::operator==(const market & other) const
{
    return
        m_left_symbol == other.left_symbol() &&
        m_right_symbol == other.right_symbol()
    ;
}

void market::lookup_ask()
{
    std::string query = "ask=" + name();

    /**
     * ask=mint/btc
     */
    stack_impl_.find(query, max_lookup_results);
    
    auto self(shared_from_this());
    
    timer_ask_lookup_.expires_from_now(std::chrono::seconds(interval_lookup));
    timer_ask_lookup_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    lookup_ask();
                }
            }
        )
    );
}

void market::lookup_bid()
{
    std::string query = "bid=" + name();

    /**
     * bid=mint/btc
     */
    stack_impl_.find(query, max_lookup_results);

    auto self(shared_from_this());
    
    timer_bid_lookup_.expires_from_now(std::chrono::seconds(interval_lookup));
    timer_bid_lookup_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    lookup_bid();
                }
            }
        )
    );
}

void market::maintain_public_asks()
{
    log_none("Market " << name() << " is maintaining public asks.");
    
    std::lock_guard<std::mutex> l1(mutex_public_asks_);
    
    /**
     * Callback
     */
    stack_impl_.on_market_public_asks(name(), m_lowest_ask, m_public_asks);
    
    /**
     * Maintain
     */
    auto it = m_public_asks.begin();
    
    /**
     * Set the initial lowest ask.
     */
    if (it == m_public_asks.end())
    {
        m_lowest_ask = 0.0f;
    }
    else
    {
        m_lowest_ask = (*it)->price();
    }
    
    while (it != m_public_asks.end())
    {
        auto a = *it;
        
        if (a)
        {
            if (a->is_expired())
            {
                log_none(
                    "Market " << name() << " public ask " << a->id() <<
                    " expired."
                );
                
                it = m_public_asks.erase(it);
            }
            else
            {
                /**
                 * Update the lowest ask.
                 */
                if (a->price() < m_lowest_ask)
                {
                    m_lowest_ask = a->price();
                }
            
                ++it;
            }
        }
        else
        {
            it = m_public_asks.erase(it);
        }
    }
    
    log_none("Market lowest ask = " << m_lowest_ask << ".");
    
    auto self(shared_from_this());
    
    timer_public_asks_.expires_from_now(
        std::chrono::seconds(interval_maintanance)
    );
    timer_public_asks_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    maintain_public_asks();
                }
            }
        )
    );
}

void market::maintain_public_bids()
{
    log_none("Market " << name() << " is maintaining public bids.");
    
    std::lock_guard<std::mutex> l1(mutex_public_bids_);
    
    /**
     * Callback
     */
    stack_impl_.on_market_public_bids(name(), m_highest_bid, m_public_bids);
    
    /**
     * Maintain
     */
    auto it = m_public_bids.begin();
    
    /**
     * Set the initial lowest ask.
     */
    if (it == m_public_bids.end())
    {
        m_highest_bid = 0;
    }
    else
    {
        m_highest_bid = (*it)->price();
    }
    
    while (it != m_public_bids.end())
    {
        auto b = *it;
        
        if (b)
        {
            if (b->is_expired())
            {
                log_none(
                    "Market " << name() << " public bid " << b->id() <<
                    " expired."
                );
                
                it = m_public_bids.erase(it);
            }
            else
            {
                /**
                 * Update the highest bid.
                 */
                if (b->price() > m_highest_bid)
                {
                    m_highest_bid = b->price();
                }
            
                ++it;
            }
        }
        else
        {
            it = m_public_bids.erase(it);
        }
    }
    
    log_none("Market highest bid = " << m_highest_bid << ".");
    
    auto self(shared_from_this());
    
    timer_public_bids_.expires_from_now(
        std::chrono::seconds(interval_maintanance)
    );
    timer_public_bids_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    maintain_public_bids();
                }
            }
        )
    );
}
