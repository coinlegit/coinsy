/**
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
=xxdb
-----END PGP PUBLIC KEY BLOCK-----
 */
 
#include <cassert>

#include <boost/algorithm/string.hpp>

#include <coinsy/http_transport.hpp>
#include <coinsy/logger.hpp>

using namespace coinsy;

http_transport::http_transport(
    boost::asio::io_service & ios, const std::string & url
    )
    : m_url(url)
    , m_secure(false)
    , m_method("GET")
    , m_status_code(-1)
    , io_service_(ios)
    , strand_(ios)
    , timeout_timer_(ios)
    , request_(new boost::asio::streambuf())
    , response_(new boost::asio::streambuf())
    , redirects_(0)
#if (defined __IPHONE_OS_VERSION_MAX_ALLOWED)
    , readStreamRef_(0)
    , writeStreamRef_(0)
#endif // __IPHONE_OS_VERSION_MAX_ALLOWED
{
    assert(!url.empty());
}

http_transport::~http_transport()
{
#if (defined __IPHONE_OS_VERSION_MAX_ALLOWED)
    if (readStreamRef_)
    {
        CFReadStreamClose(readStreamRef_);
        CFRelease(readStreamRef_), readStreamRef_ = 0;
    }
    
    if (writeStreamRef_)
    {
        CFWriteStreamClose(writeStreamRef_);
            
        CFRelease(writeStreamRef_), writeStreamRef_ = 0;
    }
#endif // __IPHONE_OS_VERSION_MAX_ALLOWED
}
  

void http_transport::start(
    const std::function<void (boost::system::error_code,
    std::shared_ptr<http_transport>)> & f
    )
{
    auto self(shared_from_this());
    
    /**
     * Set if the transport is secure.
     */
    m_secure = m_url.substr(0, 5) == "https";
    
    /**
     * Parse the url.
     */
    parse_url();
    
    /**
     * Set the completion handler.
     */
    m_on_complete = f;
    
    /**
     * Allocate the boost::asio::ssl::context.
     */
    boost::asio::ssl::context ctx(boost::asio::ssl::context::tlsv1_client);
    
    /**
     * Allocate the socket.
     */
    ssl_socket_.reset(
        new boost::asio::ssl::stream<boost::asio::ip::tcp::socket> (
        io_service_, ctx)
    );
    
    if (m_secure)
    {
        ssl_socket_->set_verify_mode(boost::asio::ssl::verify_none);

        ssl_socket_->set_verify_callback(
            [this](bool preverified, boost::asio::ssl::verify_context & ctx)
            {
#if 0
                char subject_name[256];
                X509 * cert = X509_STORE_CTX_get_current_cert(
                    ctx.native_handle()
                );
                X509_NAME_oneline(
                    X509_get_subject_name(cert), subject_name, 256
                );
                std::cout << "Verifying " << subject_name << "\n";
#endif
                return preverified;
            }
        );
    }
    
    timeout_timer_.expires_from_now(std::chrono::seconds(60));
    timeout_timer_.async_wait(
        strand_.wrap(
            [this, self](boost::system::error_code ec)
            {
                if (ec)
                {
                    // ...
                }
                else
                {
                    if (ssl_socket_)
                    {
                        ssl_socket_->lowest_layer().close();
                    }
                }
            }
        )
    );
    
    try
    {
        boost::asio::ip::tcp::resolver resolver(io_service_);
        boost::asio::ip::tcp::resolver::query query(
            m_hostname, m_secure ? "443" : "80"
        );
        do_connect(resolver.resolve(query));
    }
    catch (std::exception & e)
    {
        log_debug(
            "Http transport resolve failed, what = " << e.what() << "."
        );
        
        if (m_on_complete)
        {
            auto self(shared_from_this());
            
            boost::system::error_code ec(
                boost::asio::error::host_not_found,
                boost::system::system_category()
            );
            
            io_service_.post([this, self, ec]() { m_on_complete(ec, self); });
        }
    }
}
        
void http_transport::stop()
{
    if (ssl_socket_)
    {
        io_service_.post([this]() { ssl_socket_->lowest_layer().close(); });
    }
}

const bool & http_transport::secure() const
{
    return m_secure;
}

const std::string & http_transport::url() const
{
    return m_url;
}

const std::string & http_transport::hostname() const
{
    return m_hostname;
}

const std::string & http_transport::path() const
{
    return m_path;
}

const std::int32_t & http_transport::status_code() const
{
    return m_status_code;
}

std::map<std::string, std::string> & http_transport::headers()
{
    return m_headers;
}

void http_transport::set_request_body(const std::string & val)
{
    m_request_body = val;
    m_method = m_request_body.size() > 0 ? "POST" : "GET";
}

const std::string & http_transport::request_body() const
{
    return m_request_body;
}

const std::string http_transport::response_body() const
{
    return m_response_body.str();
}

void http_transport::do_connect(
    boost::asio::ip::tcp::resolver::iterator endpoint_iterator
    )
{
    using namespace boost;
    
    auto self(shared_from_this());
    
    asio::async_connect(ssl_socket_->lowest_layer(), endpoint_iterator,
        [this, self](system::error_code ec, asio::ip::tcp::resolver::iterator)
        {
            if (ec)
            {
                if (m_on_complete)
                {
                    m_on_complete(ec, self);
                }
            }
            else
            {
                if (m_secure)
                {
                    ssl_socket_->async_handshake(asio::ssl::stream_base::client,
                        [this, self](boost::system::error_code ec)
                        {
                            if (ec)
                            {
                                if (m_on_complete)
                                {
                                    m_on_complete(ec, self);
                                }
                            }
                            else
                            {
                                timeout_timer_.cancel();
                                
                                generate_request();
                                
                                /**
                                 * Write the http request.
                                 */
                                do_write(*request_);
                            }
                        }
                    );
                }
                else
                {
                    timeout_timer_.cancel();
                    
                    generate_request();
                    
                    /**
                     * Write the http request.
                     */
                    do_write(*request_);
                }
            }
        }
    );
#if (defined __IPHONE_OS_VERSION_MAX_ALLOWED)
    set_voip();
#endif // __IPHONE_OS_VERSION_MAX_ALLOWED
}

void http_transport::do_write(boost::asio::streambuf & buf)
{
    using namespace boost;
    
    auto self(shared_from_this());
    
    if (m_secure)
    {
        asio::async_write(*ssl_socket_, buf,
            [this, self](system::error_code ec, std::size_t)
            {
                if (ec)
                {
                    if (m_on_complete)
                    {
                        m_on_complete(ec, self);
                    }
                }
                else
                {
                    /**
                     * Read the status line.
                     */
                    asio::async_read_until(*ssl_socket_, *response_.get(), "\r\n",
                        [this, self](system::error_code ec, std::size_t)
                        {
                            if (ec)
                            {
                                if (m_on_complete)
                                {
                                    m_on_complete(ec, self);
                                }
                            }
                            else
                            {
                                handle_status_line();
                            }
                        }
                    );
                }
            }
        );
    }
    else
    {
        asio::async_write(ssl_socket_->next_layer(), buf,
            [this, self](system::error_code ec, std::size_t)
            {
                if (ec)
                {
                    if (m_on_complete)
                    {
                        m_on_complete(ec, self);
                    }
                }
                else
                {
                    /**
                     * Read the status line.
                     */
                    asio::async_read_until(
                        ssl_socket_->next_layer(), *response_.get(), "\r\n",
                        [this, self](system::error_code ec, std::size_t)
                        {
                            if (ec)
                            {
                                if (m_on_complete)
                                {
                                    m_on_complete(ec, self);
                                }
                            }
                            else
                            {
                                handle_status_line();
                            }
                        }
                    );
                }
            }
        );
    }
}

void http_transport::handle_status_line()
{
    std::istream response_stream(response_.get());
    std::string http_version;
    response_stream >> http_version;
    response_stream >> m_status_code;
    std::string status_message;
    std::getline(response_stream, status_message);
    
    auto self(shared_from_this());
    
    if (!response_stream || http_version.substr(0, 5) != "HTTP/")
    {
        boost::system::error_code ec(-1, boost::system::system_category());
        
        if (m_on_complete)
        {
            m_on_complete(ec, self);
        }
    }
    else
    {
        if (m_secure)
        {
            boost::asio::async_read_until(*ssl_socket_, *response_.get(),
            "\r\n\r\n", [this, self](boost::system::error_code ec, std::size_t)
                {
                    if (ec)
                    {
                        if (m_on_complete)
                        {
                            m_on_complete(ec, self);
                        }
                    }
                    else
                    {
                        handle_headers();
                    }
                }
            );
        }
        else
        {
            boost::asio::async_read_until(
                ssl_socket_->next_layer(), *response_.get(), "\r\n\r\n",
                [this, self](boost::system::error_code ec, std::size_t)
                {
                    if (ec)
                    {
                        if (m_on_complete)
                        {
                            m_on_complete(ec, self);
                        }
                    }
                    else
                    {
                        handle_headers();
                    }
                }
            );
        }
    }
}

void http_transport::handle_headers()
{
    std::istream response_stream(response_.get());
    std::string header;
    
    while (std::getline(response_stream, header) && header != "\r")
    {
        std::string t;
        
        std::string::size_type i;

        while ((i = header.find("\r")) != std::string::npos)
        {
            t = header.substr(0, i);
            
            header.erase(0, i + 1);
            
            if (t == "")
            {
                break;
            }
            
            i = t.find(": ");
            
            if (i == std::string::npos)
            {
                // ...
            }
            else
            {
                /**
                 * Find the key.
                 */
                std::string key = t.substr(0, i);
                
                /**
                 * Find the value.
                 */
                std::string value = t.substr(i + 2);
                
                /**
                 * Trim whitespace.
                 */
                boost::algorithm::trim(key);
                
                /**
                 * Trim whitespace.
                 */
                boost::algorithm::trim(value);
                    
                /**
                 * Insert the header field.
                 */
                m_headers.insert(std::make_pair(key, value));
            }
        }
    }

    if (response_->size() > 0)
    {
        m_response_body << response_.get();
    }

    handle_body();
}

void http_transport::handle_body()
{
    using namespace boost;
    
    auto self(shared_from_this());
    
    if (m_secure)
    {
        asio::async_read(
            *ssl_socket_, *response_.get(), asio::transfer_at_least(1),
            [this, self](system::error_code ec, std::size_t)
            {
                if (
                    ec == boost::asio::error::eof ||
                    ec.message() == "short read"
                    )
                {
                    if (m_status_code == 301 || m_status_code == 302)
                    {
                        log_debug(
                            "Http transport got " << m_status_code <<
                            ", following."
                        );
                        
                        /**
                         * Follow the redirect.
                         */
                        follow_redirect(m_headers["Location"]);
                    }
                    else
                    {
                        if (m_on_complete)
                        {
                            m_on_complete(boost::system::error_code(), self);
                        }
                    }
                }
                else if (ec)
                {
                    if (m_on_complete)
                    {
                        m_on_complete(ec, self);
                    }
                }
                else
                {
                    m_response_body << response_.get();

                    handle_body();
                }
            }
        );
    }
    else
    {
        asio::async_read(ssl_socket_->next_layer(), *response_.get(),
            asio::transfer_at_least(1),
            [this, self](system::error_code ec, std::size_t)
            {
                if (ec == boost::asio::error::eof)
                {
                    if (m_status_code == 301 || m_status_code == 302)
                    {
                        log_debug(
                            "Http transport got " << m_status_code <<
                            ", following."
                        );
                        
                        /**
                         * Follow the redirect.
                         */
                        follow_redirect(m_headers["Location"]);
                    }
                    else
                    {
                        if (m_on_complete)
                        {
                            m_on_complete(boost::system::error_code(), self);
                        }
                    }
                }
                else if (ec)
                {
                    if (m_on_complete)
                    {
                        m_on_complete(ec, self);
                    }
                }
                else
                {
                    m_response_body << response_.get();
                    
                    handle_body();
                }
            }
        );
    }
}

void http_transport::follow_redirect(const std::string & url)
{
    /**
     * Set the new url.
     */
    m_url = url;
    
    if (++redirects_ >= max_redirects)
    {
        boost::system::error_code ec(-1, boost::system::system_category());
        
        if (m_on_complete)
        {
            m_on_complete(ec, shared_from_this());
        }
    }
    else
    {
        request_.reset(new boost::asio::streambuf());
        response_.reset(new boost::asio::streambuf());

        m_headers.clear();
        m_response_body.str(std::string());
        
        start(m_on_complete);
    }
}

void http_transport::parse_url()
{
    std::string tmp_url = m_url;
    
    /**
     * Remove all occurances of http://.
     */
    boost::algorithm::erase_all(tmp_url, "http://");

    /**
     * Remove all occurances of https://.
     */
    boost::algorithm::erase_all(tmp_url, "https://");
    
    auto i = tmp_url.find_first_of("/");
    
    /**
     * Get the hostname.
     */
    m_hostname = tmp_url.substr(0, i);

    /**
     * Remove all occurances of the domain.
     */
    boost::algorithm::erase_all(tmp_url, m_hostname);
    
    i = tmp_url.find_first_of("?");
    
    std::string path = tmp_url.substr(0, i);
    
    std::string url_params = path;
    
    /**
     * Remove all occurances of the domain.
     */
    boost::algorithm::erase_all(tmp_url, url_params);
    
    url_params = tmp_url;
    
    /**
     * Get the path.
     */
    m_path = path + urlencode(url_params);
}

void http_transport::generate_request()
{
    std::ostream request_stream(request_.get());
    request_stream << m_method << " "  << m_path << " HTTP/1.0\r\n";
    request_stream << "Host: " << m_hostname << "\r\n";
    request_stream << "Accept: */*\r\n";
    request_stream << "Connection: close\r\n";
    request_stream << "Content-Length: " << m_request_body.size() << "\r\n";
    
    for (auto & i : m_headers)
    {
        request_stream << i.first << ": " << i.second << "\r\n";
    }
    
    request_stream << "\r\n";
    request_stream << m_request_body;
}

void http_transport::set_voip()
{
#if (defined __IPHONE_OS_VERSION_MAX_ALLOWED)
    /**
     * To configure a socket for VoIP usage, the only thing you have to do
     * beyond the normal configuration is add a special key that tags the 
     * interface as being associated with a VoIP service.
     */    
    CFStreamCreatePairWithSocket(
        0, (CFSocketNativeHandle)ssl_socket_->lowest_layer().native(),
        &readStreamRef_, &writeStreamRef_
    );

    if (
        !CFReadStreamSetProperty(readStreamRef_, kCFStreamNetworkServiceType,
        kCFStreamNetworkServiceTypeVoIP)
        )
    {
        log_error(
            "TCP transport failed to set service type to voip for read stream."
        );
    }
    else
    {
        log_info(
            "TCP transport set service type to "
            "kCFStreamNetworkServiceTypeVoIP for read stream."
        );
    }
    
    if (
        !CFWriteStreamSetProperty(writeStreamRef_,
        kCFStreamNetworkServiceType, kCFStreamNetworkServiceTypeVoIP)
        )
    {
        log_error(
            "TCP transport failed to set service type to voip for write stream."
        );
    }
    else
    {
        log_info(
            "TCP transport set service type to "
            "kCFStreamNetworkServiceTypeVoIP for write stream."
        );
    }
    
    if (!CFReadStreamOpen(readStreamRef_))
    {
        log_error("TCP transport unable open read stream.");
    }
    
    if (!CFWriteStreamOpen(writeStreamRef_))
    {
        log_error("TCP transport unable open write stream.");
    }
#endif // __IPHONE_OS_VERSION_MAX_ALLOWED
}

std::string http_transport::char2hex(char dec)
{
    std::string ret;
    
    char dig1 = (dec & 0xF0) >> 4;
    char dig2 = (dec & 0x0F);
    
    if (0 <= dig1 && dig1 <= 9)
    {
        dig1 += 48;
    }
    
    if (10 <= dig1 && dig1 <= 15)
    {
        dig1 += 97 - 10;
    }
    
    if (0 <= dig2 && dig2 <= 9)
    {
        dig2 += 48;
    }
    
    if (10 <= dig2 && dig2 <=15)
    {
        dig2 += 97 - 10;
    }

    ret.append(&dig1, 1);
    ret.append(&dig2, 1);
    
    return ret;
}

std::string http_transport::urlencode(const std::string & c)
{
    std::string ret;

    for (auto i = 0; i < c.length(); i++)
    {
        if (
            (48 <= c[i] && c[i] <= 57) ||
            (65 <= c[i] && c[i] <= 90) ||
            (97 <= c[i] && c[i] <= 122) ||
            (c[i]=='~' || c[i]=='!' || c[i]=='*' || c[i]=='(' || c[i]==')' ||
            c[i]=='\'' || c[i]=='?' || c[i]=='&' || c[i]=='=')
            )
        {
            ret.append(&c[i], 1);
        }
        else if (c[i] == ' ')
        {
            ret.append("+", 1);
        }
        else
        {
            ret.append("%");
            ret.append(char2hex(c[i]));
        }
    }
    return ret;
}

int http_transport::run_test()
{
    boost::asio::io_service ios;
    
    std::shared_ptr<http_transport> t =
        std::make_shared<http_transport>(ios,
        "http://coinsy.net/")
    ;

    t->start(
        [](boost::system::error_code ec, std::shared_ptr<http_transport> t)
        {
            if (ec)
            {
                std::cerr <<
                    "http_transport request failed, message = " <<
                    ec.message() <<
                std::endl;
            }
            else
            {
                if (t->status_code() == 200)
                {
                    std::cout <<
                        "http_transport success, body = " <<
                        t->response_body() <<
                    std::endl;
                }
                else
                {
                    std::cerr <<
                        "http_transport request failed, status code = " <<
                        t->status_code() <<
                    std::endl;
                }
            }
        }
    );
    
    ios.run();

    return 0;
}
