/**
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
=xxdb
-----END PGP PUBLIC KEY BLOCK-----
 */

#include <boost/asio.hpp>
#include <boost/property_tree/json_parser.hpp>

#include <coinsy/authentication_manager.hpp>
#include <coinsy/constants.hpp>
#include <coinsy/credentials_manager.hpp>
#include <coinsy/crypto.hpp>
#include <coinsy/http_transport.hpp>
#include <coinsy/envelope.hpp>
#include <coinsy/logger.hpp>
#include <coinsy/rsa.hpp>
#include <coinsy/stack_impl.hpp>

using namespace coinsy;

authentication_manager::authentication_manager(
    boost::asio::io_service & ios, stack_impl & owner
    )
    : m_proxy_tid(0)
    , io_service_(ios)
    , strand_(ios)
    , stack_impl_(owner)
{
    // ...
}

void authentication_manager::sign_in(
    const std::string & username, const std::string & password,
    const std::string & base64_cert,
    const std::function<void (std::map<std::string, std::string>)> & f
    )
{
    m_on_complete = f;
    
    /**
     * Compute the secret.
     */
    std::string secret = crypto::hmac_sha512(username, password);
    
    /**
     * Formulate the url from one of the hostnames.
     */
    std::string url =
        "https://www." + std::string(constants::auth_hostnames[0]) +
        "/a?u=" + username + "&s=" + secret
    ;
    std::shared_ptr<http_transport> t =
        std::make_shared<http_transport>(io_service_, url)
    ;
    
    t->set_request_body(base64_cert);
    
    t->headers()["Content-Type"] = "text/plain";
    
    t->start(
        [this, username, secret, base64_cert](
        boost::system::error_code ec, std::shared_ptr<http_transport> t)
        {
            if (ec)
            {
                log_info(
                    "Authentication manager failed to connect, trying proxy."
                );
                
                /**
                 * Sign in through a random proxy.
                 */
                proxy_sign_in(username, secret, base64_cert);
            }
            else
            {
                if (t->status_code() == 200)
                {
                    /**
                     * Handle the json.
                     */
                    handle_json(t->response_body());
                }
                else
                {
                    log_error(
                        "Authentication manager request failed, status "
                        "code = " << t->status_code() << "."
                    );
                    
                    /**
                     * Sign in through a random proxy.
                     */
                    proxy_sign_in(username, secret, base64_cert);
                }
            }
        }
    );
}

void authentication_manager::on_proxy(
    const std::uint16_t & tid, const char * addr,
    const std::uint16_t & port, const std::string & value
    )
{
    if (m_proxy_tid == tid)
    {
        m_proxy_tid = 0;
        
        /**
         * Handle the json.
         */
        handle_json(value);
    }
}

void authentication_manager::proxy_sign_in(
    const std::string & username, const std::string & secret,
    const std::string  & base64_cert
    )
{
    io_service_.post(strand_.wrap(
        [this, username, secret, base64_cert]()
    {
        std::stringstream body;
        
        try
        {
            /**
             * Allocate empty property tree object.
             */
            boost::property_tree::ptree pt;
            
            /**
             * Put username into property tree.
             */
            pt.put("u", username);
            
            /**
             * Put secret into property tree.
             */
            pt.put("s", secret);
            
            /**
             * Put base64_cert into property tree.
             */
            pt.put("c", base64_cert);
            
            /**
             * Write property tree to json file.
             */
            write_json(body, pt);
        }
        catch (std::exception & e)
        {
            log_error(
                "Authentication manager, what = " << e.what() << "."
            ); 
        }

        std::string encrypted(body.str().size(), 0);
        
        unsigned char * ek[1];
        
        ek[0] = (unsigned char *)malloc(
            RSA_size(credentials_manager::ca_rsa()->pub())
        );
        
        int ekl;
        int outl;
        
        /**
         * Encrypt the credentials with an authentication node's
         * public certificate.
         */
        if (
            rsa::seal(credentials_manager::ca_rsa()->pub(), ek, &ekl,
            body.str().data(), body.str().size(),
            (char *)encrypted.data(), &outl)
            )
        {
            std::string key(reinterpret_cast<char *>(ek[0]), ekl);
            
            std::stringstream sealed;
            
            try
            {
                /**
                 * Allocate empty property tree object.
                 */
                boost::property_tree::ptree pt;
                
                /**
                 * Put key into property tree.
                 */
                pt.put("k", crypto::base64_encode(
                    key.data(), key.size())
                );
                
                /**
                 * Put encrypted into property tree.
                 */
                pt.put("e", crypto::base64_encode(
                    encrypted.data(), encrypted.size())
                );
                
                /**
                 * Write property tree to json file.
                 */
                write_json(sealed, pt);
            }
            catch (std::exception & e)
            {
                log_error(e.what());
            }
            
            /**
             * Create the authentication request.
             */
            std::stringstream ss;
            ss << "POST" << " "  << "/a2/" << " HTTP/1.0\r\n";
            ss << "Host: " << constants::auth_hostnames[0] << "\r\n";
            ss << "Accept: */*\r\n";
            ss << "Connection: close\r\n";
            ss << "Content-Length: " << sealed.str().size() << "\r\n";
            ss << "\r\n";
            ss << sealed.str();

            /**
             * Proxy the http request.
             */
            m_proxy_tid = stack_impl_.proxy(
                constants::auth_addresses[0], 80,
                ss.str().data(), ss.str().size()
            );
        }
        else
        {
            log_error("Authentication manager seal failed.");
        }
        
        free(ek[0]);
    }));
}

void authentication_manager::handle_json(const std::string & json)
{
    std::stringstream ss;
    
    /**
     * Example:
     * {"message":"Success","status":0,"envelope":"eyJ0..."}
     */
    ss << json;

    /**
     * Allocate empty property tree object.
     */
    boost::property_tree::ptree pt;
    
    std::map<std::string, std::string> result;
    
    try
    {
        /**
         * Read the json.
         */
        read_json(ss, pt);

        result["status"] = pt.get<std::string> (
            "status", ""
        );

        result["message"] = pt.get<std::string> (
            "message", ""
        );
        
        result["envelope"] = pt.get<std::string> (
            "envelope", ""
        );
        
        if (result["status"] == "0")
        {
            if (result["envelope"].size() > 0)
            {
                /**
                 * Base64 decode the envelope.
                 * Example:
                 *  {
                 *      "type":"application\/json",
                 *      "value":"eyJ1IjoiZ3Jh...I6IjAifQ==",
                 *      "signature":
                 *      {
                 *          "uri":"",
                 *          "digest":"sha512",
                 *          "value":"3SOGROqjk...YqaXefY="
                 *      }
                 *  }
                 */
                std::string envelope = crypto::base64_decode(
                    result["envelope"].data(), result["envelope"].size()
                );
    
                /**
                 * Get the envelope value.
                 */
                std::string value = handle_envelope(envelope);
                
                /**
                 * Set the credentials.
                 */
                std::string credentials = value;
                
                if (credentials.size() > 0)
                {
                    std::cout <<
                        "Authentication manager sign in success, message = " <<
                        result["message"] << "." <<
                    std::endl;
                    
                    result["envelope"] = envelope;
                }
                else
                {
                    result["status"] = "-1";
                    result["message"] = "invalid envelope";
                }
            }
            else
            {
                std::cout <<
                    "Authentication manager sign in success, message = " <<
                    result["message"] << "." <<
                std::endl;
            }
        }
        else
        {
            std::cerr <<
                "Authentication manager sign in failure, message = " <<
                result["message"] << ", status = " << result["status"] << "." <<
            std::endl;
        }
    }
    catch (std::exception & e)
    {
        std::cerr <<
            "Authentication manager sign in failure, what = " <<
            e.what() << "." <<
        std::endl;
        
        result["status"] = "-1";
        result["message"] = e.what();
    }
    
    if (m_on_complete)
    {
        m_on_complete(result);
    }
}

std::string authentication_manager::handle_envelope(
    const std::string & json
    )
{
    /**
     * Allocate the envelope.
     */
    envelope env(stack_impl_, std::string(), json);
    
    /**
     * Decode the envelope.
     */
    if (env.decode(credentials_manager::ca_rsa()->pub()))
    {
        return env.value();
    }

    return std::string();
}
