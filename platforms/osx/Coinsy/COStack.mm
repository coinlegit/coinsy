/**
-----BEGIN PGP PUBLIC KEY BLOCK-----

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
=xxdb
-----END PGP PUBLIC KEY BLOCK-----
 */

#include <coinsy/stack.hpp>

#import "NSString+Additions.hpp"

#import "COStack.h"

NSString * kCODidConnectNotification = @"coDidConnectNotification";
NSString * kCODidDisconnectNotification = @"coDidDisconnectNotification";
NSString * kCODidSignInNotification = @"coDidSignInNotification";
NSString * kCODidUpdateBalanceNotification = @"coidUpdateBalanceNotification";
NSString * kCOMarketDidUpdatePublicAsksNotification = @"kCOMarketDidUpdatePublicAsksNotification";
NSString * kCOMarketDidUpdatePublicBidsNotification = @"kCOMarketDidUpdatePublicBidsNotification";
NSString * kCOAskStateDidChangeNotification = @"kCOAskStateDidChangeNotification";
NSString * kCOBidStateDidChangeNotification = @"kCOBidStateDidChangeNotification";
NSString * kCOTradeDidUpdateNotification = @"kCOTradeDidUpdateNotification";
NSString * kCOTrollboxDidUpdateNotification = @"kCOTrollboxDidUpdateNotification";
NSString * kCODidReceiveChatMessageNotification = @"kCODidReceiveChatMessageNotification";

NSString * kCOOnVersionNotification = @"coOnVersionNotification";

class my_coinsy_stack : public coinsy::stack
{
    public:
    
        /**
         * Called when connected to the network.
         * @param addr The address.
         * @param port The port.
         */
        virtual void on_connected(
            const char * addr, const std::uint16_t & port
            )
        {
            @autoreleasepool
            {
                NSMutableDictionary * dict = [NSMutableDictionary dictionary];
                
                dispatch_async(dispatch_get_main_queue(),^
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName:kCODidConnectNotification
                        object:dict
                    ];
                });
            }
        }
    
        /**
         * Called when disconnected from the network.
         * @param addr The address.
         * @param port The port.
         */
        virtual void on_disconnected(
            const char * addr, const std::uint16_t & port
            )
        {
            @autoreleasepool
            {
                NSMutableDictionary * dict = [NSMutableDictionary dictionary];
                
                dispatch_async(dispatch_get_main_queue(),^
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName:kCODidDisconnectNotification
                        object:dict
                    ];
                });
            }
        }
    
        virtual void on_sign_in(const std::string & status)
        {
            @autoreleasepool
            {
                NSMutableDictionary * dict = [NSMutableDictionary dictionary];

                [dict setObject:
                    [NSString stringWithUTF8String:status.c_str()]
                    forKey:@"status"
                ];
                
                dispatch_async(dispatch_get_main_queue(),^
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName:kCODidSignInNotification
                        object:dict
                    ];
                });
            }
        }
    
        virtual void on_balance(const std::string & symbol, const float & balance)
        {
            @autoreleasepool
            {
                NSMutableDictionary * dict = [NSMutableDictionary dictionary];

                [dict setObject:
                    [NSString stringWithUTF8String:symbol.c_str()]
                    forKey:@"symbol"
                ];
                [dict setObject:[NSNumber numberWithFloat:balance]
                    forKey:@"balance"
                ];
                
                dispatch_async(dispatch_get_main_queue(),^
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName:kCODidUpdateBalanceNotification
                        object:dict
                    ];
                });
            }
        }
    
        virtual void on_market_public_asks(
            const std::string & key, const float & lowest_price,
            const std::vector<market_public_ask_t> & public_asks
            )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];
        
            NSMutableArray * asks = [NSMutableArray new];
            
            for (auto & i : public_asks)
            {
                NSMutableDictionary * ask = [NSMutableDictionary dictionary];
                
                [ask setObject:
                    [NSNumber numberWithFloat:i.price] forKey:@"__p"
                ];
                [ask setObject:
                    [NSNumber numberWithFloat:i.quantity] forKey:@"__q"
                ];
                
                [asks addObject:ask];
            }
            
            [dict setObject:[NSNumber numberWithFloat:lowest_price]
                forKey:@"lowest_price"
            ];
            [dict setObject:asks forKey:@"asks"];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:
                    kCOMarketDidUpdatePublicAsksNotification object:dict
                ];
            });
        }
    
        virtual void on_market_public_bids(
            const std::string & key, const float & highest_price,
            const std::vector<market_public_bid_t> & public_bids
            )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];
        
            NSMutableArray * bids = [NSMutableArray new];
            
            for (auto & i : public_bids)
            {
                NSMutableDictionary * bid = [NSMutableDictionary dictionary];
                
                [bid setObject:
                    [NSNumber numberWithFloat:i.price] forKey:@"__p"
                ];
                [bid setObject:
                    [NSNumber numberWithFloat:i.quantity] forKey:@"__q"
                ];
                
                [bids addObject:bid];
            }
            
            [dict setObject:[NSNumber numberWithFloat:highest_price]
                forKey:@"highest_price"
            ];
            [dict setObject:bids forKey:@"bids"];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:
                    kCOMarketDidUpdatePublicBidsNotification object:dict
                ];
            });
        }
    
        virtual void on_ask_state(
            const std::string & key, const std::uint32_t & identifier,
            const std::uint32_t & state
        )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];
            
            [dict setObject:[NSNumber numberWithUnsignedLong:identifier]
                forKey:@"id"
            ];
            [dict setObject:[NSNumber numberWithUnsignedLong:state]
                forKey:@"state"
            ];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationQueue defaultQueue] enqueueNotification:
                    [NSNotification notificationWithName:
                    kCOAskStateDidChangeNotification object:dict]
                    postingStyle:NSPostASAP
                ];
            });
        }

        virtual void on_bid_state(
            const std::string & key, const std::uint32_t & identifier,
            const std::uint32_t & state
        )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];
            [dict setObject:[NSNumber numberWithUnsignedLong:identifier]
                forKey:@"id"
            ];
            [dict setObject:[NSNumber numberWithUnsignedLong:state]
                forKey:@"state"
            ];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationQueue defaultQueue] enqueueNotification:
                    [NSNotification notificationWithName:
                    kCOBidStateDidChangeNotification object:dict]
                    postingStyle:NSPostASAP
                ];
            });
        }
    
        virtual void on_trade(
            const std::string & key, const std::uint32_t & tid,
            std::map<std::string, std::string> & info
            )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];
            [dict setObject:[NSNumber numberWithUnsignedLong:tid]
                forKey:@"tid"
            ];

            NSMutableDictionary * dictInfo = [NSMutableDictionary dictionary];

            for (auto & i : info)
            {
                NSString * key = [NSString stringWithUTF8String:
                    i.first.c_str()
                ];
                NSString * val = [NSString stringWithUTF8String:
                    i.second.c_str()
                ];
                
                if (key && val)
                {
                    [dictInfo setObject:val forKey:key];
                }
            }
            
            [dict setObject:dictInfo forKey:@"info"];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:
                    kCOTradeDidUpdateNotification object:dict
                ];
            });
        }
    
        virtual void on_trollbox(
            const std::string & key,
            const std::vector< std::map<std::string, std::string> > & trolls
            )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];
            
            [dict setObject:
                [NSString stringWithUTF8String:key.c_str()]
                forKey:@"market"
            ];

            NSMutableArray * trollEntries = [NSMutableArray array];
            
            for (auto & i : trolls)
            {
                NSMutableDictionary * troll = [NSMutableDictionary dictionary];
                
                for (auto & j : i)
                {
                    NSString * key = [NSString stringWithUTF8String:
                        j.first.c_str()
                    ];
                    NSString * val = [NSString stringWithUTF8String:
                        j.second.c_str()
                    ];
                    
                    if (key && val)
                    {
                        [troll setObject:val forKey:key];
                    }
                }
                
                [trollEntries addObject:troll];
            }
            
            [dict setObject:trollEntries forKey:@"trolls"];
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:
                    kCOTrollboxDidUpdateNotification object:dict
                ];
            });
        }
    
        virtual void on_chat_message(
            const std::map<std::string, std::wstring> & params
            )
        {
            NSMutableDictionary * dict = [NSMutableDictionary dictionary];

            for (auto & i : params)
            {
                NSString * key = [NSString stringWithUTF8String:
                    i.first.c_str()
                ];
                NSString * val = [NSString stringWithStdWString:i.second];
                
                if (key && val)
                {
                    [dict setObject:val forKey:key];
                }
            }
            
            dispatch_async(dispatch_get_main_queue(),^
            {
                [[NSNotificationCenter defaultCenter]
                    postNotificationName:
                    kCODidReceiveChatMessageNotification object:dict
                ];
            });
        }
    
        virtual void on_find_message(
            const std::uint16_t & transaction_id,
            const std::map<std::string, std::string> & pairs,
            const std::vector<std::string> & tags
            )
        {
            // ...
        }
        
        virtual void on_find_profile(
            const std::uint16_t & transaction_id,
            const std::map<std::string, std::string> & pairs
            )
        {
            // ...
        }
    
        /**
         * Called when a version check completes.
         */
        virtual void on_version(
            const std::map<std::string, std::string> & pairs
            )
        {
            @autoreleasepool
            {
                NSMutableDictionary * dict = [NSMutableDictionary dictionary];

                for (auto & i : pairs)
                {
                    NSString * key = [NSString stringWithUTF8String:
                        i.first.c_str()
                    ];
                    NSString * val = [NSString stringWithUTF8String:
                        i.second.c_str()
                    ];
                    
                    if (key && val)
                    {
                        [dict setObject:val forKey:key];
                    }
                }
                
                dispatch_async(dispatch_get_main_queue(),^
                {
                    [[NSNotificationCenter defaultCenter]
                        postNotificationName:kCOOnVersionNotification
                        object:dict
                    ];
                });
            }
        }
    
    private:
    
    protected:
};

static my_coinsy_stack * g_my_coinsy_stack = 0;

@interface COStack ()
@property (nonatomic, strong) NSTimer * timer;
@end

@implementation COStack

+ (COStack *)sharedInstance
{
    static COStack * gCOStack = nil;
    
    if (!gCOStack)
    {
        gCOStack = [COStack new];

        [[NSNotificationCenter defaultCenter] addObserver:gCOStack
            selector:@selector(didConnectNotification:)
            name:kCODidConnectNotification object:nil
        ];
        
        [[NSNotificationCenter defaultCenter] addObserver:gCOStack
            selector:@selector(didDisconnectNotification:)
            name:kCODidDisconnectNotification object:nil
        ];
        
        [[NSNotificationCenter defaultCenter] addObserver:gCOStack
            selector:@selector(didSignInNotification:)
            name:kCODidSignInNotification object:nil
        ];
    
        [[NSUserDefaults standardUserDefaults] setObject:
            [NSNumber numberWithInt:0] forKey:@"coStatsConnects"
        ];
        
        [[NSUserDefaults standardUserDefaults] setObject:
            [NSNumber numberWithInt:0] forKey:@"coStatsDisconnects"
        ];
    }
    
    return gCOStack;
}

- (void)start
{
    if (g_my_coinsy_stack)
    {
        // ...
    }
    else
    {
        g_my_coinsy_stack = new my_coinsy_stack();
        
        g_my_coinsy_stack->start();
    }
}

- (void)start:(NSNumber *)aPort
{
    if (g_my_coinsy_stack)
    {
        // ...
    }
    else
    {
        g_my_coinsy_stack = new my_coinsy_stack();
        
        g_my_coinsy_stack->start(aPort.intValue);
    }
}

- (void)stop
{
    [self.timer invalidate];
    
    if (g_my_coinsy_stack)
    {
        g_my_coinsy_stack->stop();
        
        delete g_my_coinsy_stack, g_my_coinsy_stack = 0;
    }
    else
    {
        // ...
    }
}

- (void)signIn:(NSString *)aUsername password:(NSString *)aPassword
{
    if (g_my_coinsy_stack)
    {
        self.username = aUsername;
        
        g_my_coinsy_stack->sign_in(
            aUsername.UTF8String, aPassword.UTF8String
        );
    }
}

- (void)signOut
{
    if (g_my_coinsy_stack)
    {
        self.username = nil;
        
        g_my_coinsy_stack->sign_out();
    }
}

- (NSUInteger)find:(NSString *)aQuery
{
    if (g_my_coinsy_stack)
    {
        return g_my_coinsy_stack->find(aQuery.UTF8String, 200);
    }
    
    return 0;
}

- (NSString *)message:(NSString *)aMessage username:(NSString *)aUsername
{
    if (g_my_coinsy_stack)
    {
        return [NSString stringWithUTF8String:g_my_coinsy_stack->message(
            aUsername.UTF8String, aMessage.stdWString
        ).c_str()];
    }
    
    return nil;
}

- (void)updateProfile:(NSDictionary *)aProfile
{
    if (g_my_coinsy_stack)
    {
        std::map<std::string, std::string> profile;
        
        for (id key in aProfile)
        {
            if ([[aProfile objectForKey:key] isKindOfClass:NSString.class])
            {
                profile[[key UTF8String]] =
                    [[aProfile objectForKey:key] UTF8String
                ];
            }
        }
    
        g_my_coinsy_stack->update_profile(profile);
    }
}

- (void)updateProfile
{
    NSUserDefaults * userDefaults = [NSUserDefaults standardUserDefaults];
    
    NSString * username = [userDefaults objectForKey:@"username"];
    
    NSDictionary * preferences = [userDefaults objectForKey:username];
    
    NSDictionary * profile = [preferences objectForKey:@"profile"];
    
    if (profile || profile.count > 0)
    {
        [self updateProfile:profile];
    }
}

#pragma mark - NSNotification's

- (void)didConnectNotification:(NSNotification *)aNotification
{
    self.isConnected = YES;
    
    NSNumber * connects = [[NSUserDefaults standardUserDefaults]
        objectForKey:@"coStatsConnects"
    ];
    
    if (connects)
    {
        connects = [NSNumber numberWithInt:connects.intValue + 1];
    }
    else
    {
        connects = [NSNumber numberWithInt:1];
    }
    
    NSLog(@"Stats connects = %@", connects);
    
    [[NSUserDefaults standardUserDefaults] setObject:connects
        forKey:@"coStatsConnects"
    ];
    
    [[NSUserDefaults standardUserDefaults] synchronize];
}

- (void)didDisconnectNotification:(NSNotification *)aNotification
{
    self.isConnected = NO;
    
    NSNumber * disconnects = [[NSUserDefaults standardUserDefaults]
        objectForKey:@"coStatsDisconnects"
    ];
    
    if (disconnects)
    {
        disconnects = [NSNumber numberWithInt:disconnects.intValue + 1];
    }
    else
    {
        disconnects = [NSNumber numberWithInt:1];
    }
    
    NSLog(@"Stats disconnects = %@", disconnects);
    
    [[NSUserDefaults standardUserDefaults] setObject:disconnects
        forKey:@"coStatsDisconnects"
    ];
    
    [[NSUserDefaults standardUserDefaults] synchronize];
}

- (void)didSignInNotification:(NSNotification *)aNotification
{
    NSDictionary * dict  = aNotification.object;
    
    if ([[dict objectForKey:@"status"] intValue] == 0)
    {
        NSString * query = [NSString stringWithFormat:@"u=%@", self.username];
        
        [self performSelector:@selector(find:) withObject:query afterDelay:1.5f];
    }
    else
    {
        self.username = nil;
    }
}

#pragma mark -

- (BOOL)marketAdd:(NSString *)aMarket
{
    return g_my_coinsy_stack->market_add(aMarket.UTF8String);
}

- (BOOL)marketRemove:(NSString *)aMarket
{
    return g_my_coinsy_stack->market_remove(aMarket.UTF8String);
}

- (NSNumber *)market:(NSString *)aMarket ask:(NSDictionary *)anAsk
{
    NSNumber * price = [anAsk objectForKey:@"__p"];
    NSNumber * quantity = [anAsk objectForKey:@"__q"];
    
    return [NSNumber numberWithUnsignedInt:
        g_my_coinsy_stack->market_ask(
        aMarket.UTF8String, price.floatValue, quantity.floatValue)
    ];
}

- (NSNumber *)market:(NSString *)aMarket bid:(NSDictionary *)aBid
{
    NSNumber * price = [aBid objectForKey:@"__p"];
    NSNumber * quantity = [aBid objectForKey:@"__q"];
    
    return [NSNumber numberWithUnsignedInt:
        g_my_coinsy_stack->market_bid(
        aMarket.UTF8String, price.floatValue, quantity.floatValue)
    ];
}

- (BOOL)market:(NSString *)aMarket cancel:(NSNumber *)orderId
{
    return g_my_coinsy_stack->market_cancel(
        aMarket.UTF8String, orderId.unsignedIntValue
    );
}

- (void)market:(NSString *)aMarket troll:(NSString *)aMessage
{
    g_my_coinsy_stack->market_troll(aMarket.UTF8String, aMessage.UTF8String);
}

@end
